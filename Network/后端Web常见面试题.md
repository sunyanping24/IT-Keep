# TCP“两次握手”和“四次挥手”

 网上发现一篇比较好的文章，大部分是直接贴过来：[https://my.oschina.net/u/4198159/blog/3141874](https://my.oschina.net/u/4198159/blog/3141874)

## TCP报文段结构
一谈到 TCP 协议，大家最先想到的词就是 **「面向连接」** 和 **「可靠」** 。没错，TCP 协议的设计就是为了能够在客户端和服务器之间建立起一个可靠连接。

在讲连接过程之前，我们先来看看 TCP 的报文段结构，通过这个结构，我们可以知道 TCP 能够提供什么信息：

![https://oscimg.oschina.net/oscnet/up-e5800da775bfeadbcd150565f0455802fdf.png](https://oscimg.oschina.net/oscnet/up-e5800da775bfeadbcd150565f0455802fdf.png)

这里有几点是需要注意的：

- TCP 协议需要一个四元组（源IP，源端口，目的IP，目的端口）来确定连接，这要和 UDP 协议区分开。多说一句，IP 地址位于 IP 报文段，TCP 报文段是不含 IP 地址信息的。
- 基本 TCP 头部的长度是 20 字节，但是由于「选项」的长度是不确定的，所以需要「首部长度」字段明确给出头部长度。这里要注意的是，首部长度字段的单位是 32bit，也就是 4 字节，所以该字段的最小值是 5。
- 标橙色的字段（确认序号，接收窗口大小，ECE，ACK）用于「回复」对方，举个例子，服务器收到对方的数据包后，不单独发一个数据包来回应，而是稍微等一下，把确认信息附在下一个发往客户端的数据帧上，也就是捎带技术。
- 窗口大小是一个 16 位无符号数，也就是说窗口被限制在了 65535 字节，也就限制了 TCP 的吞吐量性能，这对一些高速以及高延迟的网络不太友好（可以想想为什么）。所幸 TCP 额外提供了窗口缩放（Window Scale）选项，允许对这个值进行缩放。

下面是 8 个标志位的含义，有的协议比较旧，可能没有前两个标志位：

![https://oscimg.oschina.net/oscnet/up-6dd2e9ca83855e78983a3726d3a1ec94f54.png](https://oscimg.oschina.net/oscnet/up-6dd2e9ca83855e78983a3726d3a1ec94f54.png)

标志位虽然很多，但是如果放到具体场景里来看的话，就很容易理解他们的作用了。

## TCP 三次握手
三次握手就是为了在客户端和服务器间建立连接，这个过程并不复杂，但里面有很多细节需要注意。

![https://oscimg.oschina.net/oscnet/up-6076656ae943ea29f47c7c045700179b93c.png](https://oscimg.oschina.net/oscnet/up-6076656ae943ea29f47c7c045700179b93c.png)

这张图就是握手的过程，可以看到客户端与服务器之间一共传递了三次消息，这三次握手其实就是两台机器之间互相确认状态，我们来一点一点看。

1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。

## 四次挥手
当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。

![https://oscimg.oschina.net/oscnet/up-37a7a58ee2a13a341095e23e0c005d90553.png](https://oscimg.oschina.net/oscnet/up-37a7a58ee2a13a341095e23e0c005d90553.png)

1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
2. 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

## 为什么要三次握手
CP作为一种可靠传输控制协议，其核心思想：**既要保证数据可靠传输，又要提高传输的效率，** 而用三次恰恰可以满足以上两方面的需求！少于3次，数据传输没有保证，多于3次传输数据降低了效率。

- 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
- 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
- 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。

## 为什么要四次挥手
任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

# 在浏览器地址栏输入一个地址->显示页面的过程都经历了什么

1. DNS域名服务器解析域名： 解析域名，找到对应的服务器地址。
2. 客户端与服务器建立TCP连接： 3次握手，建立连接，建立连接成功之后才能收发数据
3. 客户端发送HTTP请求
4. 服务器处理数据：HTTP服务器处理请求（Apache、Nginx等）
5. 返回响应结果
4. 关闭TCP连接： 4次握手
6. 浏览器解析HTML
7. 浏览器布局渲染

> 详细可以参考这篇文章：[https://segmentfault.com/a/1190000006879700](https://segmentfault.com/a/1190000006879700)

# 如何理解HTTP协议的无状态性

HTTP是一种无状态协议，即服务器不保留与客户交易时的任何状态。一次请求，一次应答，连接即就会断开。  
也就是说，上一次的请求对这次的请求没有任何影响，服务端也不会对客户端上一次的请求进行任何记录处理。

**HTTP协议的无状态性有什么问题**

用户登录后，切换到其他界面，进行操作，服务器端是无法判断是哪个用户登录的。 每次进行页面跳转的时候，得重新登录。

**解决问题的办法**

既然HTTP协议是无状态的，不会记录用户信息，那么怎么样才能让HTTP协议记录用户信息呢？换句话说，服务器怎么判断发来HTTP请求的是哪个用户？

于是，两种用于保持HTTP状态的技术就应运而生了，一个是 `Cookie`，而另一个则是 `Session`。

# `Cookie`和`Session`

![Cookie和Session](/ASSET/Cookie和Session.png)

## `Cookie`
Cookie 是客户端的存储空间，由浏览器来维持。具体来说 cookie 机制采用的是在客户端保持状态的方案。

**Cookie 的实现过程：**

Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。

也就是 Cookie 是服务器生成的，但是发送给客户端，并且由客户端来保存。每次请求加上 Cookie就行了。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

## `Session`
Session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。

客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 Session。客户端浏览器再次访问时，只需要从该 Session 中查找该客户的状态就可以了。

虽然 Session 保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为 Session 需要使用Cookie 作为识别标志。HTTP协议是无状态的，Session 不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为 JSESSIONID 的 Cookie，它的值为该 Session 的 id（即放在HTTP响应报文头部信息里的Set-Cookie）。Session依据该 Cookie 来识别是否为同一用户。

## `Cookie` 和 `Session`的区别
1. Cookie 数据存放在客户的浏览器上，Session 数据放在服务器上；
2. Cookie 不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用 Session ；
3. Session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；
4. 单个Cookie 在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；

