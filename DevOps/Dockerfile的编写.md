<!-- TOC -->

- [FROM 指定基础镜像](#from-指定基础镜像)
- [RUN 执行命令](#run-执行命令)
- [](#)

<!-- /TOC -->


Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。

# FROM 指定基础镜像
FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM **是必备的指令，并且必须是第一条指令**。

在Docker Hub上有非常多的高质量的官方镜像，可以从其中选择最符合我们终极目标的镜像为基础镜像进行定制。其中还提供了一些操作系统的镜像。除了选择现有的镜像外，Docker还存在一个特殊的镜像，**scratch**，这个镜像是虚拟的概念，并不实际存在，它表示一个空白镜像。

如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。

不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。

# RUN 执行命令
RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：
- shell 格式： `RUN <命令>`
- exec 格式：`RUN ["可执行文件", "参数1", "参数2"]`

Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。

如果多个shell命令，分行RUN <命令> 来执行，这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 

比如下面的RUN命令：
```
RUN cd /usr/src/nginx-1.17.9 \
        && mkdir /usr/local/nginx \
        && ./configure --prefix=/usr/local/nginx && make && make install \
        && ln -s /usr/local/nginx/sbin/nginx /usr/local/sbin/
```

**制作的镜像很臃肿的原因之一就是，忘记了在每一层构建完成后清理掉无用的文件。**

# 

参考文章：[Docker从入门到实践](https://yeasy.gitbooks.io/docker_practice/content/)
