<!-- TOC -->

- [什么是Docker](#什么是docker)
  - [什么是容器](#什么是容器)
  - [Docker简单介绍](#docker简单介绍)
  - [Docker容器和虚拟机的不同](#docker容器和虚拟机的不同)
- [Docker几个核心概念](#docker几个核心概念)
  - [镜像](#镜像)
  - [容器](#容器)
  - [仓库](#仓库)
- [Docker的一些底层原理](#docker的一些底层原理)

<!-- /TOC -->
# 什么是Docker

## 什么是容器

容器化越来越受欢迎，是因为 **容器有以下的特点：**
- **灵活：** 即使最复杂的应用程序也可以容器化。   
- **轻量级：** 容器利用并共享主机内核，在系统资源方面比虚拟机更加有效。
- **可移植性：** 您可以在本地构建，部署到云并在任何地方运行。
- **松散耦合：** 容器是高度自给自足并封装的容器，使您可以在不破坏其他容器的情况下更换或升级它们。
- **可扩展：** 您可以在数据中心内增加并自动分发容器副本。
- **安全：** 容器将积极的约束和隔离应用于流程，而无需用户方面的任何配置。

**我对容器通俗的理解：**   
容器就好比一个容纳东西的物体，可以在容器中放各种东西，容器是一个相对独立的空间，不会收到外界的影响，在容器的内部是一个独立的生态。有时根据对容器的介绍，觉得JDK实际上也是一个容器，java程序在JDK平台上运行。docker的 *Build, Ship and Run Any App, Anywhere* 和JDK *一次编译，到处运行* 有着异曲同工之妙。当然这只是片面的比较。其实更多的时候觉得还是更像虚拟机。甚至于与很长一段时间，都把他当作虚拟机来看待和使用的。

## Docker简单介绍

- Docker 是一种运行于 Linux 和 Windows 上的软件，用于创建、管理和编排**容器**。
- Docker 是在 GitHub 上开发的 Moby **开源**项目的一部分。Docker 公司还提供包含支持服务的**商业版本**的 Docker。

Docker 是一个构建，发布和运行应用程序的开放平台。Docker 以容器为资源分隔和调度的基本单位，容器封装了整个项目运行时所需要的所有环境，通过 Docker 你可以将应用程序与基础架构分离，像管理应用程序一样管理基础架构，以便快速完成项目的部署与交付。

## Docker容器和虚拟机的不同

下图体现了 Docker 和传统虚拟化方式的不同之处：传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，再在该系统上运行所需应用进程；而 Docker 容器内的应用进程则是直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟，因此要比传统虚拟机更为轻便。

![容器和虚拟机的对比](http://sunyanping.gitee.io/it-keep/ASSET/容器和虚拟机的对比.jpg)

简单理解：**容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。**

**总结**   
- **容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行** 。与虚拟机相比， **容器占用的空间较少**（容器镜像大小通常只有几十兆），瞬间就能完成启动 。

- **虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器**。 管理程序允许多个 VM 在一台机器上运行。每个 **VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源**，因此 **占用大量空间** 。而且 **VM 启动也十分缓慢** 。

通过 Docker 官网，我们知道了这么多 Docker 的优势，但是大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 Docker 通常用于隔离不同的应用 ，例如前端，后端以及数据库。

# Docker几个核心概念
Docker 使用 client-server 架构， Docker 客户端将命令发送给 Docker 守护进程，后者负责构建，运行和分发 Docker 容器。 Docker 客户端和守护程序使用 REST API，通过 UNIX 套接字或网络接口进行通信。核心概念如下：
![Docker的核心概念](http://sunyanping.gitee.io/it-keep/ASSET/Docker的核心概念.jpg)

## 镜像

Docker 镜像（Image）是**一个特殊的文件系统**，包含了程序运行时候所需要的资源和环境。镜像不包含任何动态数据，其**内容在构建之后也不会被改变**。

因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，充分利用 Union FS （联合文件系统）的技术，将其设计为分层存储的架构，所以**一个镜像实际上是由多层文件系统联合组成**。镜像构建时，会一层层构建，前一层是后一层的基础；每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。**因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。**

分层存储的特征使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。

## 容器
镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体，容器可以被创建、启动、停止、删除、暂停等。

**容器的实质是进程**，但与直接在宿主执行的进程不同，**容器进程运行在属于自己的、独立的命名空间中**。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样，这种特性使得容器封装的应用比直接在宿主运行更加安全。

前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层称为 容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，**任何保存于容器存储层的信息都会随容器删除而丢失**。

按照 Docker 最佳实践的要求，**容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡，因此，使用数据卷后，容器删除或者重新运行之后，数据都不会丢失。**

## 仓库
镜像构建完成后，可以很容易的在当前宿主机上运行，但如果需要在其它服务器上使用这个镜像，就需要一个集中的存储、分发镜像的服务，这就是镜像仓库（Registry）。`Docker Hub` 是 Docker 官方提供的镜像公有仓库，提供了大量常用软件的镜像，当然出于安全和保密的需要，你也可以构建自己的私有仓库。

# Docker的一些底层原理
对于docker的底层设计原理，这篇文章讲的详细清楚。这块的内容可以了解一下，若有需要使用到相关的知识时可以详细查阅资料。
[https://draveness.me/docker](https://draveness.me/docker)

**参考文档**    
闲的时候可以看看官方的文档：[https://docs.docker.com/](https://docs.docker.com/)  
作者这篇文档整理的也非常好：[https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker?id=%e4%b8%80-%e8%ae%a4%e8%af%86%e5%ae%b9%e5%99%a8](https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker?id=%e4%b8%80-%e8%ae%a4%e8%af%86%e5%ae%b9%e5%99%a8)  
大部分内容是参考这篇文章的：[https://juejin.im/post/5e1300625188253aa74a50b0](https://juejin.im/post/5e1300625188253aa74a50b0)
docker底层设计原理：[https://draveness.me/docker](https://draveness.me/docker)