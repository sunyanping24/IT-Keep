<!-- TOC -->

- [JVM概念的理解](#jvm概念的理解)
- [虚拟机的启动时机](#虚拟机的启动时机)
- [类加载机制](#类加载机制)
  - [加载](#加载)
  - [验证](#验证)
  - [准备](#准备)
  - [解析](#解析)
  - [初始化](#初始化)
- [Java内存区域](#java内存区域)
  - [程序计数器](#程序计数器)
  - [Java虚拟机栈](#java虚拟机栈)
  - [本地方法栈](#本地方法栈)
  - [Java堆](#java堆)
  - [方法区（Java8中已经移除，并在本地内存空间中开辟了”元空间“的内存区域用来做方法区需要做的事情）](#方法区java8中已经移除并在本地内存空间中开辟了元空间的内存区域用来做方法区需要做的事情)
  - [运行时常量池](#运行时常量池)
  - [在Java程序中对象如何访问](#在java程序中对象如何访问)
- [JVM垃圾回收机制（GC）](#jvm垃圾回收机制gc)
  - [需要GC的内存区域](#需要gc的内存区域)
  - [GC的对象](#gc的对象)
  - [什么时候触发GC](#什么时候触发gc)
  - [GC常用算法](#gc常用算法)
  - [垃圾收集器](#垃圾收集器)

<!-- /TOC -->

# JVM概念的理解
> JVM是Java Virtual Machine（Java虚拟机）的缩写，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域等组成。JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“一次编译，到处运行的”原因。JVM的这种解决方案按照现在的说法，可以称为容器了，比如现在流行的docker容器技术。

*Java的设计是运行在JVM的环境下的，Java的设计和C/C++有不同之处的一个地方就是内存的释放，C/C++是需要在程序中手动进行内存释放，而Java的设计把这块的工作交给了JVM，所以程序的开发过程中就可以把精力放在更应该关注的地方，但是，如果对JVM了解不深刻，那么在JVM出现内存溢出/泄露问题的时候，我们将束手无策。*

# 虚拟机的启动时机
发现网上的一段话描述的不错，直接引用在这里：
> 一个运行时的Java虚拟机实例的天职是：负责运行一个java程序。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中。
Java虚拟机实例通过调用某个初始类的main()方法来运行一个Java程序。而这个main()方法必须是共有的(public)、静态的(static)、返回值为void，并且接受一个字符串数组作为参数。任何拥有这样一个main()方法的类都可以作为Java程序运行的起点。

# 类加载机制
在开发中.java文件是需要先编译解释成.class文件，才能被JVM加载到内存中然后进行执行的。而在Java这种面向对象的语言中，这些.class文件加载到内存中后统一也是有一层抽象`Class`对象。这些在使用java的反射技术时可能需要了解的比较清楚。
JVM加载类的过程分为3步：**加载->连接->初始化**
![JVM类加载过程](/ASSET/JVM类加载过程.jpg)

## 加载
类的加载过程主要完成以下几件事情：
1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换成方法区运行时数据结构
3. 在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口

## 验证
验证这一过程，主要验证文件格式、元数据格式、字节码验证等等。

## 准备
为类变量（static）修饰的变量分配内存空间，并赋初始化值。这里注意的是，由`static final`修饰的变量则是直接初始化完成。实例变量在这里并不会分配内存空间，而是随着实例对象的创建在堆内存中创建。

## 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量；直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

## 初始化
初始化是指为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:  
（1）声明类变量时指定初始值；  
（2）使用静态代码块为类变量指定初始值。

**类的加载时机**
- 创建类的实例，也就是new一个对象  
- 访问某个类或接口的静态变量，或者对该静态变量赋值  
- 调用类的静态方法  
- 反射（Class.forName("com.xxxx.Test")）  
- 初始化一个类的子类（会首先初始化子类的父类）  
- JVM启动时标明的启动类，即文件名和类名相同的那个类 

**类加载器**
（1）根类加载器  （2）扩展类加载器  （3）系统类加载器  

**类加载机制**
（1）全盘负责  （2）双亲委派模型  （3）缓存机制

# Java内存区域
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时
间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规
定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示（有部分修改）：
![Java运行时内存区域](/ASSET/Java运行时内存区域.png)
- **本地内存：** 本地内存本不属于JVM的运行时内存区域，但是为了更全面的理解，在这里补充在这个图形中。
- **方法区：** 方法区这部分Java8中技术改变，将方法区把这部分之后被放在了本地内存区域，称为元空间

## 程序计数器
程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。

在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取
下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线
程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内
核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条
线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器
记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。

此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

实际在程序执行时，执行的是字节码文件，类似于下面这样的字节码文件。那么在程序执行时，每当获取到CPU的执行时间单元的时候，CPU实际上是不知道程序执行到哪一行了，CPU而是会根据计数器的行号指示进行执行。所以这就是程序计数器实际比较通俗的理解。
```
// 执行了相关命令，将class文件编译成了类似于汇编语言
E:\Keep\keep-server\keep-explore\target\classes\cn\qidd\other>javap -c Demo.class
Compiled from "Demo.java"
public class cn.qidd.other.Demo {
  public cn.qidd.other.Demo();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return
}
```
基于以上的分析程序计数器有以下几个特点:  
1. 线程创建的那一刻，程序计数器就必须随之被创建
2. 程序计数器是线程私有的
3. 程序计数器虽然是一块小的内存区域，但是只是用来记录当前程序执行到哪一块，并不会需要申请新的内存来保存其他什么新的指令什么的，也就不会产生内存溢出类似的问题，所以Java虚拟机规范中对此内存区域就没有规定OutOfMemeryError情况。

## Java虚拟机栈
与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 

在Java虚拟机规范中，对这个区域规定了两种异常状况：  
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
- 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。

## 本地方法栈
本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

## Java堆
对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。**Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。**这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配和回收等细节将会是下一章的主题。

根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

**Java堆内存**（后面专门整理一下）
![Java堆内存](/ASSET/Java堆内存.jpg)
- JVM内存划分为堆内存和非堆内存，堆内存分为年轻代（Young Generation）、老年代（Old Generation），非堆内存就一个永久代（Permanent Generation）。
- 年轻代又分为Eden和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1。
- 堆内存用途：存放的是对象，垃圾收集器就是收集这些对象，然后根据GC算法回收。
- 非堆内存用途：永久代，也称为方法区，存储程序运行时长期存活的对象，比如类的元数据、方法、常量、属性等。

在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存。
元空间有注意有两个参数：
- MetaspaceSize ：初始化元空间大小，控制发生GC阈值
- MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存

**移除永久代原因：** 为融合HotSpot JVM与JRockit VM（新JVM技术）而做出的改变，因为JRockit没有永久代。有了元空间就不再会出现永久代OOM问题了！

## 方法区（Java8中已经移除，并在本地内存空间中开辟了”元空间“的内存区域用来做方法区需要做的事情）
方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。

对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。

Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

## 运行时常量池
*运行时常量池（Runtime Constant Pool）是方法区的一部分。*（Java8之后就变了） Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

## 在Java程序中对象如何访问
在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：`Object obj = new Object();`

假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。

由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。 如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息.
![Java对象访问-通过句柄](/ASSET/Java对象访问1.jpg)

如果使用的是直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址.
![Java对象访问-通过指针](/ASSET/Java对象访问2.jpg)

这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。

参考原文：[https://www.cnblogs.com/gw811/archive/2012/10/18/2730117.html](https://www.cnblogs.com/gw811/archive/2012/10/18/2730117.html)

# JVM垃圾回收机制（GC）
因为JVM的内存管理模型，GC专门是设计用来回收堆内存的。因为JVM运行时的内区区域，堆内存区域是一块线程共享的内存区域，用来存放new关键字创建的对象、数组等对象的。这些对象不会自己消亡，所以需要在没有引用指向他们的时候进行回收，以释放内存空间，防止内存溢出，保证内存的可用性。而为此设计的处理方案称为GC（垃圾回收器）。

**堆内存结构**
![Java堆内存结构](/ASSET/Java堆内存结构.jpg)

## 需要GC的内存区域
jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区（java8中方法区已经被移到元空间）中，在程序运行期间，这部分内存的分配和使用都是动态的。

## GC的对象
需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。
- **引用计数：** 每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
- **可达性分析（Reachability Analysis）：** 从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。

## 什么时候触发GC
1. 程序调用System.gc时可以触发
2. 系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）

## GC常用算法
GC常用算法有：标记-清除算法，标记-压缩算法，复制算法，分代收集算法。
**目前主流的JVM（HotSpot）采用的是分代收集算法。**

1. 标记-清除算法  

为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。

|优点|缺点|
|---|---|
|最大的优点是，标记—清除算法中每个活着的对象的引用只需要找到一个即可，找到一个就可以判断它为活的。此外，更重要的是，这个算法并不移动对象的位置。|它的缺点就是效率比较低（递归与全堆对象遍历）。每个活着的对象都要在标记阶段遍历一遍；所有对象都要在清除阶段扫描一遍，因此算法复杂度较高。没有移动对象，导致可能出现很多碎片空间无法利用的情况。

![](/ASSET/GC标记-清除算法.png)

2. 标记-压缩算法

标记-压缩法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。

|优点|缺点|
|---|---|
|该算法不会像标记-清除算法那样产生大量的碎片空间。|如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。

![](/ASSET/GC标记-压缩算法.png)
左边是标记阶段，右边是整理之后的状态。可以看到，该算法不会产生大量碎片内存空间。

3. 复制算法

该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。

注意：
这个算法与标记-整理算法的区别在于，该算法不是在同一个区域复制，而是将所有存活的对象复制到另一个区域内。

|优点|缺点|
|---|---|
|实现简单；不产生内存碎片|每次运行，总有一半内存是空的，导致可使用的内存空间只有原来的一半。|

![](/ASSET/GC复制算法.png)

4. 分代收集算法
现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。

具体过程：新生代(Young)分为Eden区，From区与To区
![](/ASSET/GC分代收集算法1.png)

当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次YoungGC，也就是年轻代的垃圾回收。一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。
![](/ASSET/GC分代收集算法2.png)

这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将Eden区与From区还在被使用的对象复制到To区，
![](/ASSET/GC分代收集算法3.png)

再下一次YoungGC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。
![](/ASSET/GC分代收集算法4.png)

经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。
![](/ASSET/GC分代收集算法5.png)

老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full GC），也就是全量回收。如果Full GC使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作。

## 垃圾收集器
如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现

1. Serial收集器  
2. 并行收集器  
3. CMS收集器
4. G1收集器

可以参考阅读文章：[http://www.jobbible.cn/2019/08/16/401/](http://www.jobbible.cn/2019/08/16/401/)




 