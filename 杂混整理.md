<!-- TOC -->

- [正向代理和反向代理](#正向代理和反向代理)
- [Java中的锁](#java中的锁)
  - [公平锁/非公平锁](#公平锁非公平锁)
  - [可重入锁](#可重入锁)
  - [独享锁/共享锁](#独享锁共享锁)
  - [互斥锁/读写锁](#互斥锁读写锁)
  - [乐观锁/悲观锁](#乐观锁悲观锁)
  - [分段锁](#分段锁)
  - [偏向锁/轻量级锁/重量级锁](#偏向锁轻量级锁重量级锁)
  - [自旋锁](#自旋锁)
- [链表](#链表)
  - [链表和数组的区别](#链表和数组的区别)
  - [单向链表](#单向链表)
  - [双向链表](#双向链表)

<!-- /TOC -->

# 正向代理和反向代理
- **正向代理**：客户端将请求发送给代理服务器，并告知代理服务器需要使用哪个后台服务处理该请求，然后代理服务器，将请求发送给服务器，并将服务器响应的数据返回给客户端。    
比如：我们想要访问google服务器，在国内直接访问不了，我们可以在国外搭建一台自己的服务器，然后将访问google的请求发送到自己的国外服务器上，然后自己国外的服务器，去请求google服务，然后再将数据返回给我们。这样就是正向代理。

- **反向代理**：客户端将请求发送给代理服务器，由代理服务器自行确定使用哪台后台服务器处理该请求，然后将服务器相应的数据返回给客户端，而客户端不知道具体使用的哪台服务器处理的该请求。      
比如：我们有一个处理订单的服务，由于压力太大，我们将处理订单的服务，部署到多台服务器上，然后使用nginx做一个代理，我们只需要将请求发送到nginx服务器上，nginx服务器将我们的请求发送到某一台处理订单的服务器，然后再把数据返回给我们。这种我们就不知道使用的是哪台服务器处理的请求，这种就是反向代理。


# Java中的锁
通常所说的锁分为以下几类。    
![Java锁](http://sunyanping.gitee.io/it-keep/ASSET/Java锁.png)

## 公平锁/非公平锁
- **公平锁**：指多个线程按照申请锁的顺序来获取锁。
- **非公平锁**：指多个线程获取锁的顺序并不是按照申请锁的顺序来获取的，有可能申请晚的优先获取锁，可能造成优先级反转或者饥饿现象。
对于`ReentrantLock`而言，通过构造函数指定该锁是否是公平锁（默认是非公平锁）。非公平锁的优点在于吞吐量大。   
对于`Synchronized`而言，也是一种非公平锁。由于没有和`ReentrantLock`一样是通过AQS来实现线程的调度的机制，所以`Synchronized`不能实现公平锁。

## 可重入锁
指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。如下代码所示，调用`setB()`时会自动获得锁：
```
synchronized void setA() throws Exception{
	Thread.sleep(1000);
	setB();
}

synchronized void setB() throws Exception{
	Thread.sleep(1000);
}
```
假如调用`setB()`时，如果一直获取不到锁，那就会造成死锁，而可重入锁的好处就是可以一定上避免死锁。

## 独享锁/共享锁
- **独享锁**：该锁一次只能被一个线程所持有。
- **共享锁**：指该锁可被多个线程所持有。

对于`ReentrantLock`而言，是独享锁。但是对于Lock的另一个实现`ReadWriteLock`，读锁是共享锁，写锁是独享锁。      
对于`Synchronized`而言，是独享锁。

## 互斥锁/读写锁
上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
- 互斥锁在Java中的具体实现就是ReentrantLock
- 读写锁在Java中的具体实现就是ReadWriteLock

## 乐观锁/悲观锁
乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。      
- **悲观锁** 认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
- **乐观锁** 认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重试的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

悲观锁在Java中的使用就是通过加锁的方式。    
乐观锁在Java中的使用是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

## 分段锁
分段锁是一种锁的设计，并不是指具体什么类型的锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

## 偏向锁/轻量级锁/重量级锁
这三种锁是指锁的状态，并且是针对`synchronzied`。    
- **偏向锁**：指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
- **轻量级锁**：指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- **重量级锁**：指当锁是轻量级锁的时候，另一个线程虽然是自旋，但是自旋一直会持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁，重量级锁会让其他申请锁的线程进入阻塞，降低性能。

## 自旋锁
在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

# 链表
**链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。**

## 链表和数组的区别
数组是相同数据类型的元素按一定顺序排列的集合。数组在内存中连续，链表不连续；由于不同的存储方式导致数组静态分配内存，链表动态分配内存，数组元素在栈区，链表元素在堆区；由于数组在内存中连续，我们可以利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；但是由于数组的连续性数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。

## 单向链表
单向链表是一种简单的数据结构,在单向链表中每个节点中都会有一个引用域指向下一个节点的地址。

## 双向链表
双向链表是在单链表的每一个节点中再设置一个指向前驱节点的指针域.所以在双向链表中的节点都有两个指针域,一个指向后继,一个指向前驱.


