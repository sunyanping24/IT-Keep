<!-- TOC -->

- [缓存穿透、缓存击穿、缓存雪崩](#缓存穿透缓存击穿缓存雪崩)
- [Redis的发布订阅模式](#redis的发布订阅模式)
- [Redis为什么这么快](#redis为什么这么快)
- [Redis的集群模式](#redis的集群模式)

<!-- /TOC -->

# 缓存穿透、缓存击穿、缓存雪崩
在使用缓存的时候这几个就是比较常见的概念了  
**缓存穿透**： 需要请求的数据刚好没有做缓存这一层，而该数据却需要被频繁的查询，那就会造成数据库的压力，严重的情况下可能会导致数据库崩溃。这种情况出现的原因一般比如恶性攻击，故意使用一些可能程序未考虑的参数情况等。  
**缓存击穿**： 需要请求的数据已经做了缓存这一层，但是在需要对该数据进行查询的时候，该数据过期了，导致瞬间大量的请求转向数据库，导致数据库崩溃。  
**缓存雪崩**： 缓存数据大面积失效，大量的请求转向数据库，导致数据库崩溃。
  
缓存雪崩的问题处理方案：  
1. 设计程序时首先需要考虑到这种问题的发生的可能性。合理的设置数据的过期时间。并且在除了这一层缓存外还需要设计限流的方案，以防该情况的发生，导致数据库崩掉。比如使用hystrix限流。  
2. 如果考虑到缓存服务的稳定性导致的缓存数据失效的话，那就得保证集群的可用性。
![缓存雪崩处理方案](http://sunyanping.gitee.io/it-keep/ASSET/缓存雪崩处理方案.jpg)

缓存穿透的问题处理方案：  
1. 保证程序的设计是合理的，有大并发需要做缓存的地方都已经做了缓存。  
2. 做好请求参数的过滤处理，防止有恶行的攻击行为。直接在请求到缓存之前就已经被拒绝。

# Redis的发布订阅模式

项目中的整合可以参考：[自己的keep-server](https://gitee.com/sunyanping/keep-server/tree/master/keep-spring-data/keep-spring-data-redis)

虽然Redis也提供了发布订阅消息的功能，但是者毕竟不是Redis的主要功能，如何和Kafka、Rabbitmq这些专门的消息中间件相比的话，Redis的发布订阅功能就非常单一了，使用的场景在实际的生产中可能范围更少。
1. 发布/订阅和数据库没关系，比如连接是0的数据库发布消息，连接是1的数据只要订阅了该主题的消息就可以收到消息。
2. 主要适用一些吞吐不高、持久性要求不高、可以接受消息缺失、数据量不大的场景。比如系统刚好使用了redis，并且redis发布订阅可以满足要求，那就可以不用在引入其他的中间件增加系统的复杂度。

# Redis为什么这么快
- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速；
- 数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
- 使用多路I/O复用模型，非阻塞 IO。只有单个线程，通过跟踪每个I/O流的状态，来管理多个I/O流；
- 我们的 redis-client 在操作的时候，会产生具有不同事件类型的 socket。在服务端，有一段 I/0 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。

# Redis的集群模式
- 主从复制模式
- 哨兵（Sentinel）模式
- Cluster 集群模式