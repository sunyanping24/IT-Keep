<!-- TOC -->

- [缓存穿透、缓存击穿、缓存雪崩](#缓存穿透缓存击穿缓存雪崩)
- [Redis的发布订阅模式](#redis的发布订阅模式)
- [Redis为什么这么快](#redis为什么这么快)
- [Redis的集群模式](#redis的集群模式)
- [Redis的持久化机制](#redis的持久化机制)
  - [RDB 持久化(快照持久化)](#rdb-持久化快照持久化)
  - [AOF 持久化](#aof-持久化)
  - [Redis 4.0 对持久化机制的优化](#redis-40-对持久化机制的优化)

<!-- /TOC -->

# 缓存穿透、缓存击穿、缓存雪崩
在使用缓存的时候这几个就是比较常见的概念了  
**缓存穿透**： 需要请求的数据刚好没有做缓存这一层，而该数据却需要被频繁的查询，那就会造成数据库的压力，严重的情况下可能会导致数据库崩溃。这种情况出现的原因一般比如恶性攻击，故意使用一些可能程序未考虑的参数情况等。  
**缓存击穿**： 需要请求的数据已经做了缓存这一层，但是在需要对该数据进行查询的时候，该数据过期了，导致瞬间大量的请求转向数据库，导致数据库崩溃。  
**缓存雪崩**： 缓存数据大面积失效，大量的请求转向数据库，导致数据库崩溃。
  
缓存雪崩的问题处理方案：  
1. 设计程序时首先需要考虑到这种问题的发生的可能性。合理的设置数据的过期时间。并且在除了这一层缓存外还需要设计限流的方案，以防该情况的发生，导致数据库崩掉。比如使用hystrix限流。  
2. 如果考虑到缓存服务的稳定性导致的缓存数据失效的话，那就得保证集群的可用性。
![缓存雪崩处理方案](http://sunyanping.gitee.io/it-keep/ASSET/缓存雪崩处理方案.jpg)

缓存穿透的问题处理方案：  
1. 保证程序的设计是合理的，有大并发需要做缓存的地方都已经做了缓存。  
2. 做好请求参数的过滤处理，防止有恶行的攻击行为。直接在请求到缓存之前就已经被拒绝。

# Redis的发布订阅模式

项目中的整合可以参考：[自己的keep-server](https://gitee.com/sunyanping/keep-server/tree/master/keep-spring-data/keep-spring-data-redis)

虽然Redis也提供了发布订阅消息的功能，但是者毕竟不是Redis的主要功能，如何和Kafka、Rabbitmq这些专门的消息中间件相比的话，Redis的发布订阅功能就非常单一了，使用的场景在实际的生产中可能范围更少。
1. 发布/订阅和数据库没关系，比如连接是0的数据库发布消息，连接是1的数据只要订阅了该主题的消息就可以收到消息。
2. 主要适用一些吞吐不高、持久性要求不高、可以接受消息缺失、数据量不大的场景。比如系统刚好使用了redis，并且redis发布订阅可以满足要求，那就可以不用在引入其他的中间件增加系统的复杂度。

# Redis为什么这么快
- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速；
- 数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
- 使用多路I/O复用模型，非阻塞 IO。只有单个线程，通过跟踪每个I/O流的状态，来管理多个I/O流；
- 我们的 redis-client 在操作的时候，会产生具有不同事件类型的 socket。在服务端，有一段 I/0 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。

# Redis的集群模式
- 主从复制模式
- 哨兵（Sentinel）模式
- Cluster 集群模式

# Redis的持久化机制
Redis是内存型数据库，数据是存储在内存中的，如果数据不持久化在磁盘中，当Redis服务出现宕机、服务器故障重启问题时内存中的数据就会丢失。为了防止这种情况的发生，Redis提供了持久化功能。包含**RDB**和**AOF**两种持久化方式，默认开启的是RDB的方式。

## RDB 持久化(快照持久化)
RDB 持久化：将某个时间点的所有数据都存放到硬盘上。

可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。如果系统发生故障，将会丢失最后一次创建快照之后的数据。如果数据量很大，保存快照的时间会很长。

快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：
```
save 900 1  # 在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 300 10  #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。          
save 60 10000  #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```

## AOF 持久化
AOF 持久化：将写命令添加到 AOF 文件（Append Only File）的末尾。

与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：`appendonly yes`

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。

使用 AOF 持久化需要设置同步选项，从而确定写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。在Redis的配置文件中存在三种同步方式
```
appendfsync always  # 每个写命令都同步，这样会严重降低Redis的速度
appendfsync everysec # 每秒同步一次
appendfsync no  # 让操作系统来决定何时同步
```

## Redis 4.0 对持久化机制的优化
Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分就是压缩格式不再是 AOF 格式，可读性较差。



