<!-- TOC -->

- [MySQL的体系结构](#mysql的体系结构)
- [一条Mysql语句的执行过程](#一条mysql语句的执行过程)
- [优化器是如何选择索引的](#优化器是如何选择索引的)
- [MySQL几种连接查询的区别](#mysql几种连接查询的区别)
- [Mysql常用的字符编码格式和字符序](#mysql常用的字符编码格式和字符序)
  - [MySQL中的字符集设置](#mysql中的字符集设置)
  - [MySQL中的字符集转换过程](#mysql中的字符集转换过程)
  - [排序问题（utf8对应的常用的几种）](#排序问题utf8对应的常用的几种)
- [MySQL索引什么会失效](#mysql索引什么会失效)
- [使用EXPLAIN关键字分析SQL执行计划](#使用explain关键字分析sql执行计划)
- [什么情况下需要添加索引](#什么情况下需要添加索引)
- [单列索引和联合索引](#单列索引和联合索引)

<!-- /TOC -->

# MySQL的体系结构
MySQL的体系结构可以分成3个部分：    
- **mysql-client**： 比如一个命令行，或者Java中使用JDBC
- **mysql-server**：连接器（管理连接权限认证）、查询缓存（命中缓存的存起来）、分析器（语法分析）、优化器（执行计划选择、索引选择）、执行器（操作，返回结果）
- **mysql-存储引擎**：负责存储数据，提供读写接口（建表的时候指定MyISAM，InnoDB，Memory）

![MySQL逻辑架构](http://sunyanping.gitee.io/it-keep/ASSET/MySQL逻辑架构.jpeg)

# 一条Mysql语句的执行过程
`sql语句:select * from T where ID = 1`   

1. 连接器  
首先需要经过连接器,建立与MySQL的连接,在这里会做身份认证(验证账号密码)、权限读取(获取你的相关权限,用于做权限的逻辑判断),而且这会有个线程池用于管理线程。

2. 查询缓存   
验证身份通过后,会在查询缓存中查询找有没有缓存,命中的话就直接返回结果,否则进入分析器。查询缓存是以键值对的形式保存缓存的,key存储sql语句,value存储查询结果。  
**ps:建议关闭查询缓存。因为当表的更新时,相应表的查询缓存会被全部清空,这会导致缓存的命中率很低,维护查询缓存也会消耗一定的性能**

3. 分析器  
首先进行"词法分析",从你输入的SQL中识别出"select"则认为这是查询语句,还会识别出"T"为表名,"ID"为列名等等。然后进行"语法分析",判断整个sql语句是否错误,并判断是否存在"T"表,是否存在列"ID"

4. 优化器   
在这会对SQL语句进行优化,比如索引的选取,多表关联(join)时连接表的顺序等,然后选取最优的方案生成执行计划  
**ps:优化器有时也会有出错,比如选错索引**

5. 执行器    
首先判断该用户有无对该表查询的权限,无则直接返回,有则根据执行计划执行SQL语句。执行完成后，将结果缓存到查询缓存中,并返回结果给客户端。 

# 优化器是如何选择索引的
**优化器选择索引的目的就是：选择一个最优的执行方案，用最小的代价去执行sql**

**优化器选择索引的原则**    
选择扫描行数最少的索引（这也不是唯一的原则，也会根据是否使用临时表、是否排序等因素综合判断），但这是最重要的原则。

**优化器是如何判断扫描行数的？**    
使用统计信息的区分度。区分度越大扫描的行数越多。

**区分度：** 索引上不同的值的个数，称之为基数，基数越大，区分度也就越大。

**Mysql是如何得到统计信息的？**     
采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。但是数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。

**索引选择异常的问题可以有哪几种处理方式?**    
1. 重新统计索引信息
使用`analyze table <table_name>`命令，可以重新统计索引信息。

2. 指定使用索引
执行sql命令时，在命令中加上`force index('index_name')`来强制指定使用的索引。


# MySQL几种连接查询的区别
1. 内连接 `inner join ... on ...`
**组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。**      
![MySQL连接查询-内连接图示](http://sunyanping.gitee.io/it-keep/ASSET/MySQL连接查询-内连接图示.png)

2. 左连接 `left join ... on ...`   
** 左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。**     
![MySQL连接查询-左连接图示](http://sunyanping.gitee.io/it-keep/ASSET/MySQL连接查询-左连接图示.png)

3. 右连接 `right join ... on ...`
**右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。**      
![MySQL连接查询-右连接图示](http://sunyanping.gitee.io/it-keep/ASSET/MySQL连接查询-右连接图示.png)

4. 全连接 `... union ...` 和 `... union all ...`
`union` 语句注意事项：
- 通过`union`连接的sql两边取出的结果集列数必须一致；
- ** 使用`union` 时，完全相等的行，将会被合并**，由于合并比较耗时，一般不直接使用 `union` 进行合并，而是通常采用`union all `进行合并；**`union all` 会保留那些重复的数据**；
- 被 `union` 连接的sql 子句，单个子句中不用写 `order by` ，因为不会有排序的效果。但可以对最终的结果集进行排序；   
**union连接会将两边数据相同的行进行合并**     
![MySQL连接查询-全连接UNION图示](http://sunyanping.gitee.io/it-keep/ASSET/MySQL连接查询-全连接UNION图示.jpg)    
**union all连接不会自动合并两边相同数据行，它包含两边所有的数据行**   
![MySQL连接查询-全连接UNION ALL图示](http://sunyanping.gitee.io/it-keep/ASSET/MySQL连接查询-全连接UNION%20ALL图示.jpg)

# Mysql常用的字符编码格式和字符序
- **字符**：人类语言中最小的表义符号，比如：'A' 'B'
- **字符的编码**：给定一系列字符，对每个字符赋予一个数值，用数值来代表对应的字符，这一数值就是字符的编码(Encoding)。例如，我们给字符’A'赋予数值0，给字符’B'赋予数值1，则0就是字符’A'的编码；
- **字符集**：给定一系列字符并赋予对应的编码后，所有这些字符和编码对组成的集合就是字符集(Character Set)。例如，给定字符列表为{’A',’B'}时，{’A'=>0, ‘B’=>1}就是一个字符集；
- **字符序**：指在同一字符集内字符之间的比较规则；确定字符序后，才能在一个字符集上定义什么是等价的字符，以及字符之间的大小关系；

> 每个字符序唯一对应一种字符集，但一个字符集可以对应多种字符序，其中有一个是默认字符序(Default Collation)；   

**字符序命名规则**    
MySQL中的字符序名称遵从命名惯例：以字符序对应的字符集名称开头；以`_ci`(表示大小写不敏感)、`_cs`(表示大小写敏感)或`_bin`(表示按编码值比较)结尾。例如：在字符序`utf8_general_ci`下，字符`a`和`A`是等价的；

## MySQL中的字符集设置
- character_set_server：默认的内部操作字符集
- character_set_client：客户端来源数据使用的字符集
- character_set_connection：连接层字符集
- character_set_results：查询结果字符集
- character_set_database：当前选中数据库的默认字符集
- character_set_system：系统元数据(字段名等)字符集
- 还有以collation_开头的同上面对应的变量，用来描述字符序。

## MySQL中的字符集转换过程
1. MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；
2. 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：
    - 使用每个数据字段的CHARACTER SET设定值；
    - 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；
    - 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；
    - 若上述值不存在，则使用character_set_server设定值。

3. 将操作结果从内部操作字符集转换为character_set_results。

## 排序问题（utf8对应的常用的几种）
- `utf8_general_ci`: 不区分大小写
- `utf8_general_cs`: 区分大小写
- `utf8_bin`：字符串每个字符串用二进制数据编译存储。 区分大小写，而且可以存二进制的内容。
- `utf8_unicode_ci`：如果应用有德语、法语或者俄语，请一定使用utf8_unicode_ci

`utf8_general_ci` 和 `utf8_general_cs` 对于存储中文来说没有什么实质上的影响，因为中文不存在大小写问题。但是`utf8_general_ci`比`utf8_general_cs`的校准速度快。

# MySQL索引什么会失效
1. 使用`or`时，如果不是所有`or`连接的列都有索引，那么即使加了索引的列，查询时也不会通过索引查询。
2. like查询是以%开头，索引失效；以%结尾，索引有效
3. 查询时若存在隐式转换，则索引会失效。比如order_num字段是字符串，查询时`select * from order where order_num = 1`索引是失效的
4. Mysql查询优化器判断，通过全表扫描比通过索引查询要快，则索引失效
5. 索引列不要存储null值，查询时不要使用`is null`作为条件，否则索引会失效。
6. 对于多列索引，不是使用的第一部分，则不会使用索引。**最左匹配原则**
7. where 子句中使用!=或<>操作符索引失效。
8. 避免在索引列上使用计算，也就是说，应尽量避免在 where 子句中对字段进行表达式操作和函数操作，这将导致引擎放弃使用索引而进行全表扫描。

# 使用EXPLAIN关键字分析SQL执行计划
SQL执行计划查看一般是在查询语句前加上关键字`explain`，执行结果中可以分析SQL时如何执行的。
![](/ASSET/EXPLAIN分析SQL执行计划.png)    

- `id`： id值相同的，执行顺序自上而下；id值不同的，id值越大优先级越高。

- `select_type`
1. SIMPLE: 简单的查询，不包含子查询、union查询    
2. PRIMARY: 表示此查询时最外层的查询    
3. SUBQUERY: 代表子查询中的第一个select   
4. UNION: 表示此查询是union的第二或随后的查询     
5. DEPENDENT UNION: 表示此查询是union的第二个或者后面的查询语句，取决于外面的查询   
6. DEPENDENT SUBQUERY: 表示子查询中的第一个select，取决于外面的查询   
7. DERIVED: 衍生出来的表 

-  `table`: 查询涉及的表或者衍生出来的表

- `type`    
1. system: 表中只有一条数据
2. const: 针对主键或者唯一索引的等值查询扫描，最多只返回一条数据。
3. eq_ref: 通常出现在多表的join查询，表示对于前表的每一个结果，都只能匹配到后表的一行数据，通常查询的条件比较操作符是=,查询效率很高。
4. ref: 通常出现在join查询，针对的是非唯一或非主键索引
5. range: 表示使用索引范围查询
6. index: 表示全索引扫描
7. all: 表示全表扫描

- `possible_keys`: 查询可能使用到的索引，具体使用的哪个索引可以看key字段

- `key`: 查询时真正使用的索引

- `key_len`: 表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用

- `ref`: 表示显示的索引哪一列被使用了，如果可能的话是一个常量

- `rows`: 查询优化器根据统计信息，估算sql要查找到结果集需要扫描读取的数据行数，这个值可以非常直观的显示sql效率的好坏，原则上值越小越好

- `extra`: `explain`中的很多额外信息会在extra字段显示。常见的几种内容：
1.  using filesort: 表示mysql需要额外的排序操作，不能通过索引达到排序的效果，一般有这个的都建议优化去掉，这样的查询是非常消耗CPU资源
2.  using index: 覆盖索引扫描，表示性能可以
3. using temporary: 查询中使用到了临时表，一般出现于排序、分组、多表join，查询效率不高，建议优化
4.  using where: 使用了where过滤

# 什么情况下需要添加索引
在表中的数据达到一定数量时，查询会变得比较慢。一般除了程序编写的问题，另外需要注意给必要的字段添加索引以提高查询的效率。
1. 主键自动创建索引
2. 外键索要创建索引
3. wehere条件后的字段、作为范围查询的字段、用于分组统计排序的字段，并且这些字段被频繁使用时需要创建索引

# 单列索引和联合索引

1. 单列索引

大多数情况下，我们使用的都是单列索引。

2. 联合索引

联合索引一般用在`and`条件的时候。比如`name='name1' nad phone = '110'`。这种情况使用联合索引就会提高查询效率。

创建联合索引的时候，使用如下语句：
```
create index index_name_phone on personal(name, phone)
```
name字段在phone字段之前，这种会创建两个索引：name字段的单列索引，name和phone的联合索引。所以在使用name单列查询、使用name和phone联合查询时会使用inde_name_phone索引，但是在使用phone字段单列查询时会全表扫表。

2个字段建立联合索引时是上述的这种情况，但是3个字段建立联合索引时有点不同。

**在使用联合索引的时候可能会存在和单列索引存在字段重复的情况，比如name字段创建了单列索引，name_phone创建了复合索引，那么name字段就是重复创建了索引，在使用name字段查询的时候，会选择使用哪个索引，这个是根据mysql的查询优化器的策略来确定的，使用哪个索引查询的成本更低那么就会选择使用哪个索引**

**一般在sql优化中，能够使用联合索引的情况就优先考虑联合索引，这样就可以减少创建索引的资源占用**

