<!-- TOC -->

- [MySQL的体系结构](#mysql的体系结构)
- [一条Mysql语句的执行过程](#一条mysql语句的执行过程)
- [优化器是如何选择索引的](#优化器是如何选择索引的)
- [MySQL几种连接查询的区别](#mysql几种连接查询的区别)
- [Mysql常用的字符编码格式和字符序](#mysql常用的字符编码格式和字符序)
  - [MySQL中的字符集设置](#mysql中的字符集设置)
  - [MySQL中的字符集转换过程](#mysql中的字符集转换过程)
  - [排序问题（utf8对应的常用的几种）](#排序问题utf8对应的常用的几种)

<!-- /TOC -->

# MySQL的体系结构
MySQL的体系结构可以分成3个部分：    
- **mysql-client**： 比如一个命令行，或者Java中使用JDBC
- **mysql-server**：连接器（管理连接权限认证）、查询缓存（命中缓存的存起来）、分析器（语法分析）、优化器（执行计划选择、索引选择）、执行器（操作，返回结果）
- **mysql-存储引擎**：负责存储数据，提供读写接口（建表的时候指定MyISAM，InnoDB，Memory）

![MySQL逻辑架构](http://sunyanping.gitee.io/it-keep/ASSET/MySQL逻辑架构.jpeg)

# 一条Mysql语句的执行过程
`sql语句:select * from T where ID = 1`   

1. 连接器  
首先需要经过连接器,建立与MySQL的连接,在这里会做身份认证(验证账号密码)、权限读取(获取你的相关权限,用于做权限的逻辑判断),而且这会有个线程池用于管理线程。

2. 查询缓存   
验证身份通过后,会在查询缓存中查询找有没有缓存,命中的话就直接返回结果,否则进入分析器。查询缓存是以键值对的形式保存缓存的,key存储sql语句,value存储查询结果。  
**ps:建议关闭查询缓存。因为当表的更新时,相应表的查询缓存会被全部清空,这会导致缓存的命中率很低,维护查询缓存也会消耗一定的性能**

3. 分析器  
首先进行"词法分析",从你输入的SQL中识别出"select"则认为这是查询语句,还会识别出"T"为表名,"ID"为列名等等。然后进行"语法分析",判断整个sql语句是否错误,并判断是否存在"T"表,是否存在列"ID"

4. 优化器   
在这会对SQL语句进行优化,比如索引的选取,多表关联(join)时连接表的顺序等,然后选取最优的方案生成执行计划  
**ps:优化器有时也会有出错,比如选错索引**

5. 执行器    
首先判断该用户有无对该表查询的权限,无则直接返回,有则根据执行计划执行SQL语句。执行完成后，将结果缓存到查询缓存中,并返回结果给客户端。 

# 优化器是如何选择索引的
**优化器选择索引的目的就是：选择一个最优的执行方案，用最小的代价去执行sql**

**优化器选择索引的原则**    
选择扫描行数最少的索引（这也不是唯一的原则，也会根据是否使用临时表、是否排序等因素综合判断），但这是最重要的原则。

**优化器是如何判断扫描行数的？**    
使用统计信息的区分度。区分度越大扫描的行数越多。

**区分度：** 索引上不同的值的个数，称之为基数，基数越大，区分度也就越大。

**Mysql是如何得到统计信息的？**     
采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。但是数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。

**索引选择异常的问题可以有哪几种处理方式?**    
1. 重新统计索引信息
使用`analyze table <table_name>`命令，可以重新统计索引信息。

2. 指定使用索引
执行sql命令时，在命令中加上`force index('index_name')`来强制指定使用的索引。


# MySQL几种连接查询的区别
1. 内连接 `inner join ... on ...`
**组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。**      
![MySQL连接查询-内连接图示](http://sunyanping.gitee.io/it-keep/ASSET/MySQL连接查询-内连接图示.png)

2. 左连接 `left join ... on ...`   
** 左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。**     
![MySQL连接查询-左连接图示](http://sunyanping.gitee.io/it-keep/ASSET/MySQL连接查询-左连接图示.png)

3. 右连接 `right join ... on ...`
**右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。**      
![MySQL连接查询-右连接图示](http://sunyanping.gitee.io/it-keep/ASSET/MySQL连接查询-右连接图示.png)

4. 全连接 `... union ...` 和 `... union all ...`
`union` 语句注意事项：
- 通过`union`连接的sql两边取出的结果集列数必须一致；
- ** 使用`union` 时，完全相等的行，将会被合并**，由于合并比较耗时，一般不直接使用 `union` 进行合并，而是通常采用`union all `进行合并；**`union all` 会保留那些重复的数据**；
- 被 `union` 连接的sql 子句，单个子句中不用写 `order by` ，因为不会有排序的效果。但可以对最终的结果集进行排序；   
**union连接会将两边数据相同的行进行合并**     
![MySQL连接查询-全连接UNION图示](http://sunyanping.gitee.io/it-keep/ASSET/MySQL连接查询-全连接UNION图示.jpg)    
**union all连接不会自动合并两边相同数据行，它包含两边所有的数据行**   
![MySQL连接查询-全连接UNION ALL图示](http://sunyanping.gitee.io/it-keep/ASSET/MySQL连接查询-全连接UNION%20ALL图示.jpg)

# Mysql常用的字符编码格式和字符序
- **字符**：人类语言中最小的表义符号，比如：'A' 'B'
- **字符的编码**：给定一系列字符，对每个字符赋予一个数值，用数值来代表对应的字符，这一数值就是字符的编码(Encoding)。例如，我们给字符’A'赋予数值0，给字符’B'赋予数值1，则0就是字符’A'的编码；
- **字符集**：给定一系列字符并赋予对应的编码后，所有这些字符和编码对组成的集合就是字符集(Character Set)。例如，给定字符列表为{’A',’B'}时，{’A'=>0, ‘B’=>1}就是一个字符集；
- **字符序**：指在同一字符集内字符之间的比较规则；确定字符序后，才能在一个字符集上定义什么是等价的字符，以及字符之间的大小关系；

> 每个字符序唯一对应一种字符集，但一个字符集可以对应多种字符序，其中有一个是默认字符序(Default Collation)；   

**字符序命名规则**    
MySQL中的字符序名称遵从命名惯例：以字符序对应的字符集名称开头；以`_ci`(表示大小写不敏感)、`_cs`(表示大小写敏感)或`_bin`(表示按编码值比较)结尾。例如：在字符序`utf8_general_ci`下，字符`a`和`A`是等价的；

## MySQL中的字符集设置
- character_set_server：默认的内部操作字符集
- character_set_client：客户端来源数据使用的字符集
- character_set_connection：连接层字符集
- character_set_results：查询结果字符集
- character_set_database：当前选中数据库的默认字符集
- character_set_system：系统元数据(字段名等)字符集
- 还有以collation_开头的同上面对应的变量，用来描述字符序。

## MySQL中的字符集转换过程
1. MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；
2. 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：
    - 使用每个数据字段的CHARACTER SET设定值；
    - 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；
    - 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；
    - 若上述值不存在，则使用character_set_server设定值。

3. 将操作结果从内部操作字符集转换为character_set_results。

## 排序问题（utf8对应的常用的几种）
- `utf8_general_ci`: 不区分大小写
- `utf8_general_cs`: 区分大小写
- `utf8_bin`：字符串每个字符串用二进制数据编译存储。 区分大小写，而且可以存二进制的内容。
- `utf8_unicode_ci`：如果应用有德语、法语或者俄语，请一定使用utf8_unicode_ci

`utf8_general_ci` 和 `utf8_general_cs` 对于存储中文来说没有什么实质上的影响，因为中文不存在大小写问题。但是`utf8_general_ci`比`utf8_general_cs`的校准速度快。